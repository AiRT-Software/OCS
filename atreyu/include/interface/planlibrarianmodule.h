
#pragma pack(push, 1)

/*
    The plan librarian is in charge of storing and providing missions from the database in the server.
    Each mission is identified using a GUID created in the client. A GUID has this format:

    123e4567-e89b-12d3-a456-426655440000    
    
    A mission is made of:

    -a json file with the metadata
    -a json file with the flight plans
    -a map
    -a thumbnail

    A mission requires all those three components (thumbnails and maps may be generated by jiminy). 
    The map can be of three types:

    -a point cloud captured by the MapCam
    -a 3d model stored in a 3d file built in a third party tool
    -a box defined by the user. The box is also stored in a file

    Each type of map has a default thumbnail.

    Thus, the workflow of a planning session would be:

    1. The user selects an existing mission (a) or creates a new one (b)
    (a)
    Missions may reside locally or in the server. If we have a connection to the server, the UI will
    show both. If there is a local mission and a remote mission, we have to check if they are the same
    (download its metadata file and check if they are the same or not.) If there are two versions of 
    the same mission, the user can work only with the local one.

    2. The GCS requests the number of missions in the server (PLAN_LIB_REQUEST_NUMBER_PLANS_IN_DDBB)
    3. And then requests the base name of each mission, given its index (PLAN_LIB_REQUEST_BASE_NAME)
    4. Then it retrieves the pathnames for the thumbnail and metadata files for building the menu 
        (PLAN_LIB_REQUEST_MISSION and PLAN_LIB_REQUEST_PLAN_THUMBNAIL)
    5. The user selects a mission 
    (b)
    2. The GCS asks the user for a map (an existing 3d file or the size of a box to be used as the map)
    3. The GCS asks the user for the mission metadata
    4. The GCS generates a GUID (<guid>)
    
    And then...
    10. The user edits an existing flight plan, adds a new plan, deletes an existing plan, etc. (locally)

    At some point, the client will want to upload a mission to the server:
    
    20. The GCS requests the library path (PLAN_LIB_REQUEST_LIBRARY_PATH)
    21. The GCS uploads the map as <librarypath>/<guid>.<extension>.map
    22. The GCS uploads the mission file as <librarypath>/<guid>.json.mission
    23. The GCS uploads the thumbnail as <librarypath>/<guid>.<extension>.thumb
    24. The GCS uploads the metada as <librarypath>/<guid>.json.metadata

    Note that we can be updating an existing mission. Just rewrite the files.

    Jiminy can also delete missions from the server (PLAN_LIB_DELETE_MISSION).

*/

// ACTIONS
// Non payload actions are built using a single AiRT command packet:
// { 'A', PLAN_LIB_MODULE, <ACTION>}
// where <ACTION> can be any of the \sa StdMessage::PlanLibrarianCommandType that do not require a parameter

// Request the base name of a plan, given an index (0..numberOfPlans-1)
struct RequestPlanBaseName
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_MODULE, StdMessage::PLAN_LIB_REQUEST_BASE_NAME};
    uint32_t index;
};

// Two part-message. The second part has the base name (asciiz)
struct RequestThumbnail
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_MODULE, StdMessage::PLAN_LIB_REQUEST_THUMBNAIL};
};

// Two part-message. The second part has the base name (asciiz)
struct RequestMission
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_MODULE, StdMessage::PLAN_LIB_REQUEST_MISSION};
};

// Two part-message. The second part has the base name (asciiz)
struct RequestMap
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_MODULE, StdMessage::PLAN_LIB_REQUEST_MAP};
};

// Two part-message. The second part has the base name (asciiz)
struct RequestMetadata
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_MODULE, StdMessage::PLAN_LIB_REQUEST_METADATA};
};

// Two-part message. The second part has the mission guid (asciiz),
struct DeleteMission
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_MODULE, StdMessage::PLAN_LIB_DELETE_MISSION};
};

// NOTIFICATIONS
// Number of plans in the server database
struct NumberOfPlansNotifications
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_NOTIFICATIONS_MODULE, StdMessage::PLAN_LIB_NUMBER_PLANS_IN_DDBB_NOTIFICATION};
    uint32_t numberOfPlans;
};

// Library path. Two-part message. The second part has the asciiz string of the library folder
struct MissionLibraryPathNotification
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_NOTIFICATIONS_MODULE, StdMessage::PLAN_LIB_LIBRARY_PATH_NOTIFICATION};
};

// Error: the requested mission index does not exists (it should be between 0 and the numberOfPlans-1)
struct MissionIndexNotFoundNotification
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_NOTIFICATIONS_MODULE, StdMessage::PLAN_LIB_MISSION_INDEX_NOT_FOUND_NOTIFICATION};
    uint32_t index;
};

// Two-part message. Error : the requested mission component does not exists (the second part has the filename)
struct FileNotFound
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_NOTIFICATIONS_MODULE, StdMessage::PLAN_LIB_FILE_NOT_FOUND_NOTIFICATION};
};

// Two-part message. The second part has the base name
struct BaseNameNotification
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_NOTIFICATIONS_MODULE, StdMessage::PLAN_LIB_BASE_NAME_NOTIFICATION};
    uint32_t index; // Index of the mission in the ddbb
};

// Two-part message. The second part has the full pathname in the server
struct MetadataNotification
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_NOTIFICATIONS_MODULE, StdMessage::PLAN_LIB_METADATA_NOTIFICATION};
};

// Two-part message. The second part has the full pathname in the server
struct ThumbnailNotification
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_NOTIFICATIONS_MODULE, StdMessage::PLAN_LIB_THUMBNAIL_NOTIFICATION};
};

// Two-part message. The second part has the full pathname in the server
struct MissionNotification
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_NOTIFICATIONS_MODULE, StdMessage::PLAN_LIB_MISSION_NOTIFICATION};
};

// Two-part message. The second part has the full pathname in the server
struct MapNotification
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_NOTIFICATIONS_MODULE, StdMessage::PLAN_LIB_MAP_NOTIFICATION};
};

// Two-part message. The second part has the mission guid
struct DeletedMissionNotification
{
    const AIRT_Message_Header header{StdMessage::PLAN_LIBRARIAN_NOTIFICATIONS_MODULE, StdMessage::PLAN_LIB_MISSION_DELETED_NOTIFICATION};
};

#pragma pack(pop)